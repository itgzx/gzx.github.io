<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-vue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/09/vue/" class="article-date">
  <time datetime="2020-07-09T00:37:59.000Z" itemprop="datePublished">2020-07-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/09/vue/">vue</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>—-Vue 篇—-</p>
<p>1，vue 的生命周期？</p>
<p>vue 的生命周期主要分为几个阶段，数据初始化，dom 挂载，数据更新，组件卸载， 在一个就是开启了组件缓存的时候，会有组件启用和组件停用阶段，每个阶段都去前 后两个钩子除了缓存的那俩</p>
<p>数据初始化阶段<br>beforeCreate：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事 件配置之前被调用。<br>created：实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观 测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段 还没开始，$el 属性目前不可见.</p>
<p>dom 挂载阶段<br>beforeMount：在挂载开始之前被调用：相关的 render 函数首次被调用.<br>mounted：el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染 完毕，可以用 vm.$nextTick 替换掉 mounted</p>
<p>数据更新阶段<br>beforeUpdate：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 updated：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩 子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操 作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通 常最好使用计算属性或 watcher 取而代之。 updated 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完 毕，可以用 vm.$nextTick 替换掉 updated</p>
<p>缓存启用的时候会有下面两个钩子<br>activated：keep-alive 组件激活时调用。<br>deactivated：keep-alive 组件停用时调用.</p>
<p>组件卸载的时候:<br>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 202<br>destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定， 所有的事件监听器会被移除，所有的子实例也会被销毁。</p>
<p>2，vue 实现数据双向绑定的原理<br>vue 实现数据双向绑定主要是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息 给订阅者，触发相应的监听回调。</p>
<p>具体话其实就是通过 Obeject.defineProperty() 中 的 setter 和 getter 来监听属性变动实现</p>
<p>Observer 进行数据的监听然后就是通知订阅 者，那么订阅者其实就是简单的一个数组，这个数组中的内容就是我门使用了的一个 数据的集合，使用了的数据可以通过 getter 得到，其实就是在调用的时候给数组里面 添加一个订阅者这样就是实现了一个 Watcher（需要监听的数据的集合），然后在实 现一个 Compile 其作用就是解析模板指令，将模板中的变量替换成数据，然后初始化 渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一 旦数据有变动，收到通知，更新视图。</p>
<p>其实 vue 的数据双向绑定就是 MVVM 作为数 据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听 自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭 起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变 化(input) -&gt; 数据 model 变更的双向绑定效果。</p>
<p>3，vue 路由的实现原理<br>在 vue 中路由主要有 hash 与 History interface 两种方式实现前端路由。</p>
<p>单页路由的 特点就是采用前端路由系统，通过改变 URL，在不重新请求页面的情况下，更新页面 视图。</p>
<p>目前在浏览器环境中这一功能的实现主要有两种方式：hash 和 History interface，这两种模式的实现分别是</p>
<p>先说 hash，在浏览器的 url 中 hash（“#”）符号的本来作用是加在 URL 中指示网 页中的位置：#符号本身以及它后面的字符称之为 hash，可通过 window.location.hash 属性读取。它具几个特点就是：hash 虽然出现在 URL 中，但 不会被包括在 HTTP 请求中。它是用来指导浏览器动作的，对服务器端完全无用，因 此，改变 hash 不会重新加载页面，并且可以为 hash 的改变添加 hashchange 监听 事件，在一个就是每一次改变 hash（window.location.hash），都会在浏览器的访 问历史中增加一个记录，我就可以通过他的这几个特点实现一个 hash 模式的单页路 由，通过对 location.hash 的修改实现 push 方法（跳转页面），通过对 location.href 的修改实现 replace()方法，通过对 hashchange 事件的监听实现页面 跳转后的数据更新</p>
<p>History 模式则是完全采用了 h5 的新特性，从 HTML5 开始，History interface 提供了两个新的方法：pushState(), replaceState()使得我们可以对浏览器历史记录栈 进行修改，以及 popState 事件可以监听到状态的变更</p>
<p>不过 history 模式有一个问题就是 对于单页应用来讲，理想的使用场景是仅在进入应用时加载 index.html，后续在的网 络操作通过 Ajax 完成，不会根据 URL 重新请求页面，但是如果用户直接在地址栏中 输入并回车，浏览器重启重新加载的时候 history 模式则会将 URL 修改得就和正常请 求后端的 URL 一样，在此情况下重新向后端发送请求，如后端没有配置对应 的路由 处理，则会返回 404 错误。这种问题的解决，一般情况下我们都是在后端进行配置， 将所有的路由请求都指向 index.html 文件</p>
<p>4，vue 组件的通讯？</p>
<p>1.父组件传子组件</p>
<pre><code>单项数据流 props

使用 refs 访问子组件

使用$parent 访问父组件

使用$children 访问子组件

使用$root 访问当前组件树的根 Vue 实例

在 template 元素使用 scope 可以访问到子组件中 slot 元素的属性值 要 13k</code></pre><p>2.子组件传递数据给父组件</p>
<pre><code>子组件通过事件给父组件传数据，子组件通过$emit（eventName）触发事件，父 组件通过$on 监听事件</code></pre><p>3.兄弟组件间通信</p>
<pre><code>（1）用事件发布订阅 var bus=new vue（）；bus.$emit(&quot;id-selected&quot;,1)；bus.$on （&quot;id-selected&quot;,function(id){}）

（2）用 vuex 来实现</code></pre><p>5，VueX 是做什么的？</p>
<p>Vuex 是适用于 Vue.js 应用的状态管理库，为应用中的所有组件提供集中式的状态存 储与操作，保证了所有状态以可预测的方式进行修改</p>
<p>state: state 定义了应用状态的数据结构，同样可以在这里设置默认的初始状 态.</p>
<p>actions:Actions 即是定义提交触发更改信息的描述，常见的例子有从服务端获 取数据，在数据获取完成后会调用 store.commit()来调用更改 Store 中的状态。可以 在组件中使用 dispatch 来发出 Actions。</p>
<p>mutations: 调用 mutations 是唯一允许更新应用状态的地方。 getters: Getters 允许组件从 Store 中获取数据，譬如我们可以从 Store 中的 projectList 中筛选出已完成的项目列表</p>
<p>modules: modules 对象允许将单一的 Store 拆分为多个 Store 的同时保存在 单一的状态树中。随着应用复杂度的增加，这种拆分能够更好地组织代码 但是 vuex 也有缺点就是，vuex 中保存的数据是和网页的生命周期同步的，当执行页 面刷新的时候 vuex 中所有数据都会消失复位到初始状态，所以不太适合做有分享页 面的数据交互（在这种项目中 vuex 只适合数据的集中管理，不适合数据的存储，这 种情况一般是使用路由传递参数会好一些），适合后台管理系统多一些，后台管理系 统一般都是公司内部使用</p>
<p>6，Vue 的路由如何传参？ <router-link :to="{path:‘details‘,query: {id:el.tog_line_id}}"> &lt;router-link :to=”{name:‘details‘,params: {id:el.tog*line_id}}”&gt; 然后在组件内部通过$route.params 来读取数据，但是路由传递的参数值是对象的话 就不行了会报错，一般都是在传递之前先吧需要传递的数据使用 base64 转化一下就 不会造成路由报错了</p>
<p>7，Vue 和 angular 的区别？ 1.在 API 与设计两方面上 Vue.js 都比 Angular 简单得多，因此你可以快速地掌握 它的全部特性并投入开发。 2.Vue.js 是一个更加灵活开放的解决方案。它允许你以希望的方式组织应用程序， 而不是任何时候都必须遵循 Angular 制定的规则。它仅仅是一个视图层，所以你可以 将它嵌入一个现有页面而不一定要做成一个庞大的单页应用。在配合其他库方面它给 了你更大的的空间，但相应，你也需要做更多的架构决策。例如，Vue.js 核心默认不205<br>包含路由和 Ajax 功能，并且通常假定你在应用中使用了一个模块构建系统。这可能 是最重要的区别。 3.Angular 使用双向绑定，Vue 也支持双向绑定，不过默认为单向绑定，数据从父 组件单向传给子组件。在大型应用中使用单向绑定让数据流易于理解。 4.在 Vue.js 中指令和组件分得更清晰。指令只封装 DOM 操作，而组件代表一个自 给自足的独立单元 —— 有自己的视图和数据逻辑。在 Angular 中两者有不少相混的 地方。5.Vue.js 有更好的性能，并且非常非常容易优化，因为它不使用脏检查。Angular， 当 watcher 越来越多时会变得越来越慢，因为作用域内的每一次变化，所有 watcher 都要重新计算。并且，如果一些 watcher 触发另一个更新，脏检查循环（digest cycle）可能要运行多次。 Angular 用户常常要使用深奥的技术，以解决脏检查循环 的问题。有时没有简单的办法来优化有大量 watcher 的作用域。Vue.js 则根本没有这 个问题，因为它使用基于依赖追踪的观察系统并且异步列队更新，所有的数据变化都 是独立地触发，除非它们之间有明确的依赖关系。唯一需要做的优化是在 v-for 上使 用 track-by.</p>
<p>8，Vue 和 SEO？ vue 主要一个开发框架，通过 vue－router 可以实现单页应用的开发，但是单页应用 本身就对 seo 不友好，现在 vue 官方给出的解决方案是 vue-server-renderer 服务端 渲染，但是我觉得对于一个真正适合做成单页应用的项目的话，seo 其实是可以不用 考虑的，反正项目本身是需要登录才能进入的，但是像其他一些类似于商城的项目的 话，我们可以吧项目分开，像单个的详情页我们没有必要放到单页路由中，可以把她 们分出去，毕竟对于商城来说商品才是详情才是需要 seo 优化的。或者我们完全没有 必要用了 vue 就得吧项目做成单页的，我们可以使用一些他的特性，毕竟我觉得 vue 给我带来最大的好处就是组件化开发</p>
<p>9，Vue 的优缺点？ 优点： 简单：官方文档很清晰，比 Angular 简单易学。 快速：异步批处理方式更新 DOM。组合：用解耦的、可复用的组件组合你的应用程 序。紧凑：~18kb min+gzip，且无依赖。 强大：表达式 &amp; 无需声明依赖的可推导属性 (computed properties)。 对模块友好：可以通过 NPM、Bower 或 Duo 安装，不强迫你所有的代码都遵循 Angular 的各种规定，使用场景更加灵活。 vue 作者是中国人。哈哈 206<br>缺点： 不兼容 ie8，不过总体上觉得 vue 对我来说还是非常不错的，能看的懂文档，能上的 去手，开发模式也比较好</p>
<p>10，Vue 的脚手架有几种？ 5 种 simple,webpack-simple,vue-cli,browserify,browser-simple </p>
<p>11，指令 keep-alive 指令 keep-alive 是做组件缓存的，就是把组件缓存起来不会销毁，下次打开这个组件 直接显示出来，如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新 渲染。一般用于有上啦加载的页面，因为如果一个页面有上啦加载的话，用户加载了 好几页了都然后点击进入详情，在返回又得重新加载，这个体验很不好，有了 keep- alive 后就可以吧这个列表页面保存在内存中避免用户的重复操作，增强用户体验</p>
<p>12.如何让 css 只在当前组件中起作用 在每一个 vue 组件中都可以定义各自的 css，js，如果希望组件内写的 css 只对当前组 件起作用，只需要在 style 中写入 scoped，即： <style scoped></style></p>
<p>13.Vuejs 在变化检测问题 1.检测数组 由于 javascript 的限制，vuejs 不能检测到下面数组的变化： 直接索引设置元素，如 vm.item[0]={}; 修改数据的长度，如 vm.item.length。 为了解决问题 1，Vuejs 扩展了观察数组，为它添加一个$set()方法： // 与 <code>example1.items[0] = ...</code> 相同，但是能触发视图更新 example1.items.$set(0, { childMsg: ‘Changed!’}) 问题 2，需要一个空数组替换 items。 除了$set()，vuejs 也为观察数组添加了$remove()方法，用于从目标数组中查找并删 除元素，在内部调用了 splice()。因此，不必： 207<br>var index = this.items.indexOf(item) if (index !== -1) { this.items.splice(index, 1) }只需： this.items.$remove(item); 2.检测对象 受 ES5 的显示，Vuejs 不能检测到对象属性的添加或删除。因为 Vuejs 在初始化时候 将属性转化为 getter/setter，所以属性必须在 data 对象才能让 Vuejs 转换它，才能 让它是响应的，例如： var data = { a: 1 } var vm = new Vue({ data: data })// <code>vm.a</code> 和 <code>data.a</code> 现在是响应的 vm.b = 2 // <code>vm.b</code> 不是响应的 data.b = 2 // <code>data.b</code> 不是响应的 不过，有办法在实例创建之后添加属性并且让它是响应的。对于 Vue 实例，可以使用 $set(key,value)实例方法： vm.$set(‘b’, 2) // <code>vm.b</code> 和 <code>data.b</code> 现在是响应的 对于普通数据对象，可以使用全局方法 Vue.set(object, key, value): Vue.set(data, ‘c’, 3) // <code>vm.c</code> 和 <code>data.c</code> 现在是响应的 208<br>有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 *.extend() 添加 属性。但是，添加到对象上的新属性不会触发更新。这时可以创建一个新的对象，包 含原对象的属性和新的属性： // 不使用 <code>Object.assign(this.someObject, { a: 1, b: 2 })</code> this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })</p>
<p>14.关于 vuejs 页面闪烁 在 vuejs 指令中有 v-cloak，这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如[v-cloak]{display:none}一起用时，这个指令可以隐藏未编译的 Mustache 标 签直到实例准备完毕。用法如下： [v-cloak]{ display:none; }<div v-cloak></div> 这样<div>不会显示，直到编译结束</p>
<p>15.组件命名的约定 当注册组件（或者 props）时，可以使用 kebab-case ，camelCase ，或 TitleCase // 在组件定义中 components: { // 使用 kebab-case 形式注册 ‘kebab-cased-component’: { /_ … <em>/ }, // register using camelCase ‘camelCasedComponent’: { /</em> … <em>/ }, // register using TitleCase ‘TitleCasedComponent’: { /</em> … _/ } }在 HTML 模版中，只能使用 kebab-case 形式： <!-- 在 HTML 模版中始终使用 kebab-case --> 209<br><kebab-cased-component></kebab-cased-component> <camel-cased-component></camel-cased-component> <title-cased-component></title-cased-component> 当使用字符串模式时可以使用 camelCase 、 TitleCase 或者 kebab-case 来引用： <!-- 在字符串模版中可以用任何你喜欢的方式! --> <my-component></my-component> <myComponent></myComponent> <MyComponent></MyComponent></p>
<p>16.key 的使用 一般情况下，vue 在渲染完成后，如果数据发生变化，只会重新渲染数据，不会重新 渲染整个元素，但是有时候我们需要元素被重新渲染，此时就需要使用 key 关键字， 使用 v-bind 绑定 key 关键字，可以实现在数据发生变化时候重新渲染整个元素。 注：同一父级元素下所有子元素如果都要在数据变化后重新渲染元素，则需要被绑定 的 key</p>
<p>17，$route 和$router 的区别 $route 是路由信息对象，包含了 path，params，query，hash，fullPath， matched，name 这些路由信息参数 而$router 是路由实例对象包含了路由的一些跳转方法，钩子函数等</p>
<p>18，vue 路由的钩子函数 官方称为导航守卫可以控制导航的跳转，有 beforeEach，afterEach 等，一般用于页 面 title 的修改，一些需要登录才能调整页面的重定向等功能，beforeEach 主要有 3 个参数 to, from, next to: Route: 即将要进入的目标 路由对象 from: Route: 当前导航正要离开的路由 next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的 调用参数。可以控制网页的跳转</p>
<p>19，watch，computed，methods 的区别？ watch 是做单一的数据监听，方法名字必须和需要监听的数据同名，不需要返回值， 可以得到数据修改前后修改后的值 210<br>computed 和 methods 基本相同，都是方法，都是在数据改变的时候如果方法内部 有该数据的依赖都是自动执行， 但是它们俩定位不同，computed 是计算属性，而 methods 是放的操作方法， 还有就是调用形式不同，计算属性调用不需要加括弧，methods 则需要加（） 在一个就是 computed 会将计算的值进行缓存，如果方法内部依赖的值没有发生变化 调用 computed 不管多少次都只是执行一次，其他调用反回的是缓存的值，而 methods 则调用多少次就会执行多少次</p>
<p>20，vue 中 sync 的用处？ vue 中 sync 其实就是自定义事件的一个语法糖 <comp :foo.sync="bar"></comp> 会被扩展为： &lt;comp :foo=”bar” @update:foo=”val =&gt; bar = val”&gt;</comp> 当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件： this.$emit(‘update:foo’, newValue) 所以他的好处就是简化了自定义事件的写法。</p>
<p>21，vue 组件怎么划分？ 按着页面的框架去划分，将页面中的每一块都可以划分成为一个组件，然后从中提取 公共组件，一般都是将组件分为页面组件和公共组件</p>
<p>22，vue 的插件  element - 饿了么出品的 Vue2 的 web UI 工具套件  Vux - 基于 Vue 和 WeUI 的组件库  mint-ui - Vue 2 的移动 UI 元素</p>
<p>24，vue 的自定义指令 一. 请谈谈 Vue 中的 MVVM 模式 MVVM 全称是 Model-View-ViewModel 211<br>212 Vue 是以数据为驱动的，Vue 自身将 DOM 和数据进行绑定，一旦创建绑定，DOM 和数据 将保持同步，每当数据发生变化，DOM 会跟着变化。 ViewModel 是 Vue 的核心，它是 Vue 的一个实例。Vue 实例时作用域某个 HTML 元素上的这个 HTML 元素可以是 body， 也可以是某个 id 所指代的元素。 DOMListeners 和 DataBindings 是实现双向绑定的关键。DOMListeners 监听页面所有 View 层 DOM 元素的变化，当发生变化，Model 层的数据随之变化；DataBindings 监听 Model 层的数据，当数据发生变化，View 层的 DOM 元素随之变化。 二. v-show 和 v-if 指令的共同点和不同点?  v-show 指令是通过修改元素的 displayCSS 属性让其显示或者隐藏  v-if 指令是直接销毁和重建 DOM 达到让元素显示和隐藏的效果 三. 如何让 CSS 只在当前组件中起作用? 将当前组件的<style>修改为<style scoped> 四. <keep-alive></keep-alive>的作用是什么? <keep-alive></keep-alive> 包裹动态组件时，会缓存不活动的组件实例,主要用于保 留组件状态或避免重新渲染。 大白话: 比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt; 打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使 用<keep-alive></keep-alive>进行缓存，这样用户每次返回列表的时候，都能从缓存 中快速渲染，而不是重新渲染 五. Vue 中引入组件的步骤? 1.采用 ES6 的 import … from …语法或 CommonJS 的 require()方法引入组件<br>六. 指令 v-el 的作用是什么? 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标.可以是 CSS 选择 器，也可以是一个 HTMLElement 实例, 七. 在 Vue 中使用插件的步骤 1. 采用 ES6 的 import … from …语法或 CommonJSd 的 require()方法引入插件 2. 使用全局方法 Vue.use( plugin )使用插件,可以传入一个选项对象 Vue.use(My Plugin, { someOption: true }) 八. 请列举出 3 个 Vue 中常用的生命周期钩子函数? 1. created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性 和方法的运算, watch/event 事件回调. 然而, 挂载阶段还没有开始, $el 属性 目前还不可见 2. mounted: el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如 果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档 内。 3. activated::keep-alive 组件激活时调用 九. 请简述下 Vuex 的原理和使用方法 213<br>214 数据单向流动 一个应用可以看作是由上面三部分组成: View, Actions,State,数据的流动也是从 Vi ew =&gt; Actions =&gt; State =&gt;View 以此达到数据的单向流动.但是项目较大的, 组件嵌 套过多的时候, 多组件共享同一个 State 会在数据传递时出现很多问题.Vuex 就是为 了解决这些问题而产生的. Vuex 可以被看作项目中所有组件的数据中心,我们将所有组件中共享的 State 抽离出 来,任何组件都可以访问和操作我们的数据中心. Vuex 原理 上图可以很好的说明 Vuex 的组成,一个实例化的 Vuex.Store 由 state, mutations 和 actions 三个属性组成:  state 中保存着共有数据  改变 state 中的数据有且只有通过 mutations 中的方法,且 mutations 中的方法 必须是同步的  如果要写异步的方法,需要些在 actions 中, 并通过 commit 到 mutations 中进 行 state 中数据的更改. 更多 Vuex 信息,请参考 Vuex 官网 : vuex.vuejs.org<br>十. 请谈谈 Vue 框架和 Angular.js 和 React 的不同 参见:Vue 对比其他框架 作者：Lee_tanghui 链接：<a href="https://www.jianshu.com/p/e54a9a34a773" target="_blank" rel="noopener">https://www.jianshu.com/p/e54a9a34a773</a> 來源：简书 2、下列面试题 active-class 是哪个组件的属性？ vue-router 模块的 router-link 组件。 嵌套路由怎么定义？ 在实际项目中我们会碰到多层嵌套的组件组合而成，但是我们如何实现嵌套路由呢？ 因此我们需要在 VueRouter 的参数中使用 children 配置，这样就可以很好的实现路 由嵌套。 index.html，只有一个路由出口 <div id="app"> <!-- router-view 路由出口, 路由匹配到的组件将渲染在这里 --> <router-view></router-view> </div> main.js，路由的重定向，就会在页面一加载的时候，就会将 home 组件显示出来，因 为重定向指向了 home 组件，redirect 的指向与 path 的必须一致。children 里面是子 路由，当然子路由里面还可以继续嵌套子路由。 import Vue from ‘vue’ import VueRouter from ‘vue-router’ Vue.use(VueRouter) //引入两个组件 import home from “./home.vue” import game from “./game.vue” //定义路由 const routes = [ 215<br>{ path: “/“, redirect: “/home” },//重定向,指向了 home 组件 { path: “/home”, component: home, children: [ { path: “/home/game”, component: game } ] } ]//创建路由实例 const router = new VueRouter({routes}) new Vue({ el: ‘#app’, data: { },methods: { },router })home.vue，点击显示就会将子路由显示在出来，子路由的出口必须在父路由里面，则 子路由无法显示。 <template> <div><h3>首页</h3> <router-link to="/home/game"> <button>显示<tton> </router-link> <router-view></router-view> </div> </template> game.vue <template> <h3>游戏</h3> </template> 怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数？ 在 router 目录下的 index.js 文件中，对 path 属性加上/:id。 使用 router 对象的 params.id。 vue-router 有哪几种导航钩子？ 216<br>三种， 第一种：是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判 断拦截。 第二种：组件内的钩子 第三种：单独路由独享组件 scss 是什么？在 vue.cli 中的安装使用步骤是？有哪几大特性？ css 的预编译。 使用步骤： 第一步：用 npm 下三个 loader（sass-loader、css-loader、node-sass） 第二步：在 build 目录找到 webpack.base.config.js，在那个 extends 属性中加一个 拓展.scss 第三步：还是在同一个文件，配置一个 module 属性 第四步：然后在组件的 style 标签加上 lang 属性 ，例如：lang=”scss” 有哪几大特性: 1、可以用变量，例如（$变量名称=值）； 2、可以用混合器，例如（） 3、可以嵌套 mint-ui 是什么？怎么使用？说出至少三个组件使用方法？ 基于 vue 的前端组件库。npm 安装，然后 import 样式和 js，vue.use（mintUi）全局 引入。在单个组件局部引入：import {Toast} from ‘mint-ui’。 组件一：Toast(‘登录成功’)； 组件二：mint-header； 组件三：mint-swiper v-model 是什么？怎么使用？ vue 中标签怎么绑定事件？ 可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。vue 的 model 层的 data 属性。绑定事件：&lt;input @click=doLog()/&gt; 217<br>218 iframe 的优缺点？ iframe 也称作嵌入式框架，嵌入式框架和框架网页类似，它可以把一个网页的框架和 内容嵌入在现有的网页中。 优点： . 解决加载缓慢的第三方内容如图标和广告等的加载问题 . Security sandbox . 并行加载脚本 . 方便制作导航栏 缺点： . iframe 会阻塞主页面的 Onload 事件 . 即时内容为空，加载也需要时间 . 没有语意 简述一下 Sass、Less，且说明区别？ 他们是动态的样式语言，是 CSS 预处理器,CSS 上的一种抽象层。他们是一种特殊的语 法/语言而编译成 CSS。 变量符不一样，less 是@，而 Sass 是$; Sass 支持条件语句，可以使用 if{}else{},for{}循环等等。而 Less 不支持; Sass 是基于 Ruby 的，是在服务端处理的，而 Less 是需要引入 less.js 来处理 Less 代码输出 Css 到浏览器 axios 是什么？怎么使用？描述使用它实现登录功能的流程？ 请求后台资源的模块。npm install axios -S 装好，然后发送的是跨域，需在配置文 件中 config/index.js 进行设置。后台如果是 Tp5 则定义一个资源路由。js 中使用 im port 进来，然后.get 或.post。返回在.then 函数中如果成功，失败则是在.catch 函 数中 axios+tp5 进阶中，调用 axios.post(‘api/user’)是进行的什么操作？axios.put (‘api/user/8′)呢？ 跨域，添加用户操作，更新操作。 vuex 是什么？怎么使用？哪种功能场景使用它？<br>vue 框架中状态管理。在 main.js 引入 store，注入。新建了一个目录 store，….. e xport 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车 mvvm 框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？ 一个 model+view+viewModel 框架，数据模型 model，viewModel 连接两个 区别：vue 数据驱动，通过数据来显示视图层而不是节点操作。 场景：数据操作比较多的场景，更加便捷 自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子 函数参数？ 全局定义指令：在 vue 对象的 directive 方法里面有两个参数，一个是指令名称，另 外一个是函数。组件内定义指令：directives 钩子函数：bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件 内相关更新） 钩子函数参数：el、binding 说出至少 4 种 vue 当中的指令和它的用法？ v-if：判断是否隐藏；v-for：数据循环出来；v-bind:class：绑定一个属性；v-mode l：实现双向绑定 vue-router 是什么？它有哪些组件？ vue 用来写路由一个插件。router-link、router-view 导航钩子有哪些？它们有哪些参数？ 导航钩子有： a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterU pdate、beforeRouteLeave 参数： 219<br>有 to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下 一个路由，如果不用就拦截）最常用就这几种 Vue 的双向数据绑定原理是什么？ vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.definePropert y()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应 的监听回调。 具体步骤： 第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 se tter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化 第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面 视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有 变动，收到通知，更新视图 第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个 update()方法 3、待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退。 第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利 用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新； 视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。 请详细说下你对 vue 生命周期的理解？ 总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后 创建前/后： 在 beforeCreated 阶段，vue 实例的挂载元素$el 和数据对象 data 都为 undefined，还未初始化。在 created 阶段，vue 实例的数据对象 data 有了，$el 还没 有。 .. 220<br>载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂 载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂 载完成，data.message 成功渲染。 更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。 销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此 时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在 . 请说下封装 vue 组件的过程？ 首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块， 解决了我们传统项目开发：效率低、难维护、复用性等问题。 然后，使用 Vue.extend 方法创建一个组件，然后使用 Vue.component 方法注册组件。 子组件需要数据，可以在 props 中接受定义。而子组件修改好数据后，想把数据传递 给父组件。可以采用 emit 方法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/09/vue/" data-id="ckce7zo8b0000vov9dkic4baa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/09/vue/">vue</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>